<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <title>Animated Inscription</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .image-container {
            width: 100%;
            height: 180px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            overflow: hidden;
            background: #000;
        }

        .animation-viewport {
            position: absolute;
            height: 168px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
            overflow: hidden;
        }

        #animationCanvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="image-container">
        <div class="animation-viewport">
            <canvas id="animationCanvas"></canvas>
        </div>
    </div>

    <script>
    const PARAMS = {
        frameCount: 36,
        frameDelay: 16,
        rotationRange: 0.08,
        pressDownStrength: 30,
        insertionStrength: 40,
        insertionAngle: 0.06,
        squashStrength: 0.15,
        displayDuration: 5000,
        baseSize: 28,
        hdScale: 6,
        transitionDuration: 500,
        nodDuration: 800,
        exitDuration: 7500,
        entranceDuration: 7500,
        movementRange: 2.0,
    };

    const container = document.querySelector('.animation-viewport');
    const canvas = document.getElementById('animationCanvas');
    const ctx = canvas.getContext('2d', { 
        alpha: true,
        willReadFrequently: false 
    });

    // Set canvas size once and cache it
    function calculateOptimalSize(height) {
        return { width: container.clientWidth, height: height };
    }
    const size = calculateOptimalSize(container.clientHeight);
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;

    // Use a separate offscreen canvas for image processing
    const offscreenCanvas = new OffscreenCanvas(size.width, size.height);
    const offscreenCtx = offscreenCanvas.getContext('2d', {
        alpha: true,
        willReadFrequently: true
    });


    const imageCache = new Map();

    async function preloadImage(url) {
        if (imageCache.has(url)) {
            return imageCache.get(url);
        }
        
        const img = new Image();
        img.crossOrigin = 'anonymous';
        
        const promise = new Promise((resolve, reject) => {
            img.onload = () => {
                imageCache.set(url, img);
                resolve(img);
            };
            img.onerror = reject;
        });
        
        img.src = url;
        return promise;
    }

    let animationFrameId;
    let lastFrameTime = performance.now();

    function animate() {
        animationFrameId = requestAnimationFrame(animateFrame);
    }

    function stopAnimation() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
    }

    function animateFrame() {
        const currentTime = performance.now(); 
        if (currentTime - lastFrameTime >= PARAMS.frameDelay) {
            lastFrameTime = currentTime;
            // Rest of your animation code would go here.  Example:
            // ctx.clearRect(0, 0, canvas.width, canvas.height);
            // ctx.fillStyle = 'red';
            // ctx.fillRect(10, 10, 50, 50);

        }
        animationFrameId = requestAnimationFrame(animateFrame);
    }

    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            stopAnimation();
        } else {
            animate();
        }
    });

    window.addEventListener('blur', stopAnimation);
    window.addEventListener('focus', animate);

    animate();

    </script>
</body>
</html>

